// Author: Meer Patel

import { Request, Response } from "express";
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();
import { format, eachDayOfInterval } from 'date-fns'; // Utility functions for date handling

// Get total number of users

export const getTotalUsers = async (req: Request, res: Response) => {
    try {
        // Get all users sorted by their creation date
        const users = await prisma.user.findMany({
            select: {
                createdAt: true,
            },
            orderBy: {
                createdAt: 'asc',
            },
        });

        // Check if there are users
        if (users.length === 0) {
            return res.json({ totalUsers: 0, totalUsersData: [] });
        }

        // Extract the creation dates and sort them
        const creationDates = users.map((user: any) => user.createdAt);

        // Get the earliest and latest creation dates
        const startDate = creationDates[0];
        const endDate = creationDates[creationDates.length - 1];

        // Generate a list of all dates between the earliest and latest creation date
        const allDates = eachDayOfInterval({ start: startDate, end: endDate });

        // Prepare data for the chart
        let cumulativeCount = 0;
        const totalUsersData = allDates.map(date => {
            cumulativeCount += users.filter((user: any) => user.createdAt <= date).length;
            return {
                date: format(date, 'yyyy-MM-dd'), // Format date for labels
                count: cumulativeCount,
            };
        });

        // Send the response
        res.json({ totalUsers: users.length, totalUsersData });
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
};

// Get new users per day/week/month
// const getNewUsers = async (req: Request, res: Response) => {
//     try {
//         const { startDate, endDate } = req.query; // e.g., '2024-01-01', '2024-01-31'
//         const newUsers = await prisma.user.count({
//             where: {
//                 createdAt: {
//                     gte: new Date(startDate),
//                     lte: new Date(endDate),
//                 },
//             },
//         });
//         res.json({ newUsers });
//     } catch (error: any) {
//         res.status(500).json({ error: error.message });
//     }
// };

// Get most popular tour packages by bookings
export const getPopularTourPackages = async (req: Request, res: Response) => {
    try {
        const popularPackages = await prisma.tourPackage.findMany({
            orderBy: {
                Bookings: { _count: 'desc' },
            },
            include: {
                Bookings: true,
            },
        });
        res.json({ popularPackages });
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
};

// Get total revenue generated by tour packages
export const getTotalRevenue = async (req: Request, res: Response) => {
    console.log("ttrrry");

    try {
        // Fetch all bookings with their tourPackage price and createdAt date
        const bookings = await prisma.bookings.findMany({
            select: {
                createdAt: true,
                tourPackage: {
                    select: {
                        price: true,
                    },
                },
            },
            orderBy: {
                createdAt: 'asc',
            },
        });

        // Check if there are any bookings
        if (bookings.length === 0) {
            return res.json({ totalRevenue: 0, totalRevenueData: [] });
        }

        // Extract the creation dates and calculate the total revenue for each date
        const creationDates = bookings.map((booking: any) => booking.createdAt);
        const startDate = creationDates[0];
        const endDate = creationDates[creationDates.length - 1];
        const allDates = eachDayOfInterval({ start: startDate, end: endDate });

        // Prepare data for the chart
        let cumulativeRevenue = 0;
        const totalRevenueData = allDates.map(date => {
            const dailyRevenue = bookings
                .filter((booking: any) => format(booking.createdAt, 'yyyy-MM-dd') === format(date, 'yyyy-MM-dd'))
                .reduce((total: any, booking: any) => total + booking.tourPackage.price, 0);
            cumulativeRevenue += dailyRevenue;
            return {
                date: format(date, 'yyyy-MM-dd'),
                amount: cumulativeRevenue,
            };
        });

        // Send the response
        res.json({ totalRevenue: cumulativeRevenue, totalRevenueData });
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
};

// Get average rating of tour packages
export const getAverageRating = async (req: Request, res: Response) => {
    try {
        const averageRating = await prisma.review.aggregate({
            _avg: {
                rating: true,
            },
        });
        res.json({ averageRating });
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
};

// Get total bookings
export const getTotalBookings = async (req: Request, res: Response) => {
    try {
        const totalBookings = await prisma.bookings.count();
        res.json({ totalBookings });
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
};

// Get comments analytics
export const getCommentsAnalytics = async (req: Request, res: Response) => {
    try {
        const commentsCount = await prisma.comment.count();
        res.json({ commentsCount });
    } catch (error: any) {
        res.status(500).json({ error: error.message });
    }
};

